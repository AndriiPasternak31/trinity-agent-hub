#!/usr/bin/env python3
"""trinity-market: Install agents on Trinity from the marketplace.

A standalone tool that deploys agents to a Trinity instance via its REST API.
Handles everything: database setup, agent creation, credential injection.

Usage:
    trinity-market configure          # Set Trinity URL and credentials
    trinity-market list               # List available agents
    trinity-market search <query>     # Search agents
    trinity-market info <name>        # Show agent details
    trinity-market install <name>     # Install an agent or system
    trinity-market status             # Show installed agents

Dependencies: requests, pyyaml (pip install requests pyyaml)
"""

from __future__ import annotations

import argparse
import getpass
import json
import os
import re
import shutil
import subprocess
import sys
import textwrap
import time
from pathlib import Path
from typing import Any

try:
    import requests
except ImportError:
    print("Error: 'requests' package required. Install with: pip install requests")
    sys.exit(1)

try:
    import yaml
except ImportError:
    print("Error: 'pyyaml' package required. Install with: pip install pyyaml")
    sys.exit(1)


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

CONFIG_DIR = Path.home() / ".trinity-market"
CONFIG_FILE = CONFIG_DIR / "config.yaml"
VERSION = "0.2.0"

DEFAULT_REGISTRY_URL = (
    "https://raw.githubusercontent.com/AndriiPasternak31/trinity-agent-hub/main/registry.yaml"
)

PLACEHOLDER_RE = re.compile(r"\$\{([A-Z_][A-Z0-9_]*)(?::-(.*?))?\}")

# Pre-generated JWT for local PostgREST (role: service_role, expires: year 2100)
# Secret: trinity-local-smarts-jwt-secret-key-min32chars!!
LOCAL_DB_JWT = (
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9."
    "eyJyb2xlIjoic2VydmljZV9yb2xlIiwiaXNzIjoidHJpbml0eS1sb2NhbCIsImlhdCI6MTcwMDAwMDAwMCwiZXhwIjo0MTAyNDQ0ODAwfQ."
    "igi8xFQDTC1RaCe8IZgP6kCkkQntUxv6Iy-0Tp5CL-E"
)
LOCAL_DB_URL = "http://smarts-api:3000"
LOCAL_DB_JWT_SECRET = "trinity-local-smarts-jwt-secret-key-min32chars!!"


# ---------------------------------------------------------------------------
# Embedded Infrastructure Files
# ---------------------------------------------------------------------------
# These are written to disk by the CLI when needed — no Trinity fork required.

SMARTS_DOCKER_COMPOSE = textwrap.dedent("""\
    # Auto-generated by trinity-market for SMARTS local database
    services:
      smarts-db:
        image: postgres:16-alpine
        container_name: smarts-db
        restart: unless-stopped
        environment:
          POSTGRES_DB: smarts
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: smarts-local-dev
        volumes:
          - smarts-db-data:/var/lib/postgresql/data
          - ./smarts-db-init.sql:/docker-entrypoint-initdb.d/01-init.sql:ro
        networks:
          - trinity-agent-network
        healthcheck:
          test: ["CMD-SHELL", "pg_isready -U postgres -d smarts"]
          interval: 10s
          timeout: 5s
          retries: 5
          start_period: 10s
        mem_limit: 512m

      smarts-postgrest:
        image: postgrest/postgrest:v12.2.3
        container_name: smarts-postgrest
        restart: unless-stopped
        environment:
          PGRST_DB_URI: postgres://authenticator:trinity-local-auth@smarts-db:5432/smarts
          PGRST_DB_SCHEMAS: public
          PGRST_DB_ANON_ROLE: anon
          PGRST_JWT_SECRET: trinity-local-smarts-jwt-secret-key-min32chars!!
          PGRST_SERVER_HOST: "0.0.0.0"
          PGRST_SERVER_PORT: "3000"
        depends_on:
          smarts-db:
            condition: service_healthy
        networks:
          - trinity-agent-network
        mem_limit: 256m

      smarts-api:
        image: nginx:alpine
        container_name: smarts-api
        restart: unless-stopped
        volumes:
          - ./smarts-nginx.conf:/etc/nginx/conf.d/default.conf:ro
        depends_on:
          - smarts-postgrest
        ports:
          - "3001:3000"
        networks:
          - trinity-agent-network
        mem_limit: 64m

    volumes:
      smarts-db-data:

    networks:
      trinity-agent-network:
        external: true
""")

SMARTS_INIT_SQL = textwrap.dedent("""\
    -- Auto-generated by trinity-market for SMARTS local database
    CREATE ROLE anon NOLOGIN;
    CREATE ROLE service_role NOLOGIN;
    CREATE ROLE authenticator LOGIN PASSWORD 'trinity-local-auth';
    GRANT anon TO authenticator;
    GRANT service_role TO authenticator;
    GRANT USAGE ON SCHEMA public TO anon, service_role;
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO service_role;
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO service_role;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO service_role;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO service_role;
    GRANT SELECT ON ALL TABLES IN SCHEMA public TO anon;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO anon;

    CREATE TABLE IF NOT EXISTS integration_context (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        context_type TEXT NOT NULL,
        symbol TEXT,
        created_by TEXT NOT NULL,
        context_data JSONB NOT NULL,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        expires_at TIMESTAMP WITH TIME ZONE NOT NULL
    );
    CREATE INDEX IF NOT EXISTS idx_ic_type ON integration_context(context_type);
    CREATE INDEX IF NOT EXISTS idx_ic_symbol ON integration_context(symbol) WHERE symbol IS NOT NULL;
    CREATE INDEX IF NOT EXISTS idx_ic_created_by ON integration_context(created_by);
    CREATE INDEX IF NOT EXISTS idx_ic_created_at ON integration_context(created_at DESC);
    CREATE INDEX IF NOT EXISTS idx_ic_expires_at ON integration_context(expires_at DESC);

    CREATE TABLE IF NOT EXISTS trading_evaluations (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        symbol TEXT NOT NULL, action TEXT NOT NULL, decision_id TEXT NOT NULL,
        analysis_id TEXT, opportunity_id TEXT,
        entry_price NUMERIC NOT NULL, stop_loss NUMERIC NOT NULL, take_profit NUMERIC NOT NULL,
        expected_value NUMERIC, confidence NUMERIC(3,2),
        execution_id TEXT, status TEXT NOT NULL DEFAULT 'pending',
        fill_price NUMERIC, filled_quantity NUMERIC, order_quantity NUMERIC,
        exit_price NUMERIC, exit_reason TEXT, closed_at TIMESTAMPTZ,
        pnl_dollars NUMERIC, pnl_pct NUMERIC(5,2), holding_hours NUMERIC,
        personality TEXT, market_regime TEXT, technical_score NUMERIC(3,2),
        created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    CREATE INDEX IF NOT EXISTS idx_te_symbol ON trading_evaluations(symbol);
    CREATE INDEX IF NOT EXISTS idx_te_status ON trading_evaluations(status);
    CREATE INDEX IF NOT EXISTS idx_te_created_at ON trading_evaluations(created_at DESC);

    CREATE TABLE IF NOT EXISTS trading_metrics (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        period TEXT NOT NULL, period_start TIMESTAMPTZ NOT NULL, period_end TIMESTAMPTZ NOT NULL,
        trades_opened INTEGER, trades_closed INTEGER, win_count INTEGER, loss_count INTEGER,
        win_rate NUMERIC(5,2), total_pnl_dollars NUMERIC, total_pnl_pct NUMERIC(5,2),
        gross_profit NUMERIC, gross_loss NUMERIC, profit_factor NUMERIC(5,2),
        sharpe_ratio NUMERIC(5,2), max_drawdown_pct NUMERIC(5,2),
        avg_trade_size NUMERIC, best_trade_pnl NUMERIC, worst_trade_pnl NUMERIC,
        avg_winning_trade NUMERIC, avg_losing_trade NUMERIC,
        setup_performance JSONB, personality TEXT,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS pm_directives (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        agent_id TEXT NOT NULL, target_agent_id TEXT,
        directive_type TEXT NOT NULL, symbol TEXT,
        reason TEXT NOT NULL, priority TEXT NOT NULL DEFAULT 'normal',
        status TEXT NOT NULL DEFAULT 'active',
        valid_until TIMESTAMPTZ, acknowledged_at TIMESTAMPTZ, executed_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS agent_configurations (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        agent_id TEXT NOT NULL UNIQUE, agent_name TEXT NOT NULL,
        personality TEXT NOT NULL DEFAULT 'balanced',
        min_confidence_buy NUMERIC(3,2) NOT NULL DEFAULT 0.60,
        min_confidence_sell NUMERIC(3,2) NOT NULL DEFAULT 0.60,
        max_position_pct NUMERIC(3,2) NOT NULL DEFAULT 0.03,
        min_risk_reward_ratio NUMERIC(3,2) NOT NULL DEFAULT 1.50,
        rsi_oversold_threshold NUMERIC(4,1) NOT NULL DEFAULT 30.0,
        rsi_overbought_threshold NUMERIC(4,1) NOT NULL DEFAULT 70.0,
        volume_confirmation_ratio NUMERIC(3,1) NOT NULL DEFAULT 1.5,
        symbols TEXT[] NOT NULL DEFAULT '{AAPL,MSFT,GOOGL,AMZN,NVDA,META,TSLA,SPY,QQQ,AMD}',
        scan_interval_minutes INTEGER DEFAULT 15, max_daily_trades INTEGER DEFAULT 10,
        position_sizing_method TEXT DEFAULT 'risk_based',
        daily_loss_limit_pct NUMERIC(3,1) DEFAULT 3.0,
        max_position_loss_pct NUMERIC(3,1) DEFAULT 8.0,
        created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS trading_reports (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        period TEXT NOT NULL, report_date DATE NOT NULL,
        report_content TEXT, summary JSONB, insights JSONB, patterns JSONB,
        generated_by TEXT, generated_at TIMESTAMPTZ DEFAULT NOW()
    );

    CREATE OR REPLACE FUNCTION update_updated_at() RETURNS TRIGGER AS $$
    BEGIN NEW.updated_at = NOW(); RETURN NEW; END; $$ LANGUAGE plpgsql;

    CREATE TRIGGER tr_te_updated BEFORE UPDATE ON trading_evaluations
        FOR EACH ROW EXECUTE FUNCTION update_updated_at();
    CREATE TRIGGER tr_ac_updated BEFORE UPDATE ON agent_configurations
        FOR EACH ROW EXECUTE FUNCTION update_updated_at();

    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO service_role;
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO service_role;
    GRANT SELECT ON ALL TABLES IN SCHEMA public TO anon;
""")

SMARTS_NGINX_CONF = textwrap.dedent("""\
    server {
        listen 3000;
        server_name _;
        location /rest/v1/ {
            proxy_pass http://smarts-postgrest:3000/;
            proxy_set_header Host $host;
            proxy_pass_request_headers on;
            add_header Access-Control-Allow-Origin * always;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, PATCH, DELETE, OPTIONS" always;
            add_header Access-Control-Allow-Headers "apikey, Authorization, Content-Type, Prefer" always;
            if ($request_method = OPTIONS) { return 204; }
        }
        location /health { return 200 '{"status":"ok"}'; add_header Content-Type application/json; }
    }
""")


# ---------------------------------------------------------------------------
# Colors
# ---------------------------------------------------------------------------

class C:
    OK = "\033[92m"
    WARN = "\033[93m"
    ERR = "\033[91m"
    BOLD = "\033[1m"
    DIM = "\033[2m"
    RESET = "\033[0m"

    @classmethod
    def disable(cls) -> None:
        cls.OK = cls.WARN = cls.ERR = cls.BOLD = cls.DIM = cls.RESET = ""


if not sys.stdout.isatty():
    C.disable()


# ---------------------------------------------------------------------------
# Config
# ---------------------------------------------------------------------------

def load_config() -> dict[str, Any]:
    if not CONFIG_FILE.exists():
        return {}
    return yaml.safe_load(CONFIG_FILE.read_text()) or {}


def save_config(cfg: dict[str, Any]) -> None:
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    CONFIG_FILE.write_text(yaml.dump(cfg, default_flow_style=False))


def get_config_or_exit() -> dict[str, Any]:
    cfg = load_config()
    if not cfg.get("trinity_url"):
        print(f"{C.ERR}Not configured.{C.RESET} Run: trinity-market configure")
        sys.exit(1)
    if not cfg.get("api_key") and not cfg.get("admin_password"):
        print(f"{C.ERR}No credentials configured.{C.RESET} Run: trinity-market configure")
        sys.exit(1)
    return cfg


# ---------------------------------------------------------------------------
# Trinity API Client
# ---------------------------------------------------------------------------

class TrinityAPI:
    """Client for Trinity REST API. Supports both MCP key and admin password auth."""

    def __init__(self, base_url: str, api_key: str | None = None,
                 admin_password: str | None = None) -> None:
        self.base_url = base_url.rstrip("/")
        self.session = requests.Session()
        self.session.headers["Content-Type"] = "application/json"

        if api_key:
            self.session.headers["Authorization"] = f"Bearer {api_key}"
        elif admin_password:
            self._login(admin_password)

    def _login(self, password: str) -> None:
        """Login as admin and get JWT token."""
        r = requests.post(
            f"{self.base_url}/token",
            data={"username": "admin", "password": password},
            headers={"Content-Type": "application/x-www-form-urlencoded"},
            timeout=10,
        )
        r.raise_for_status()
        token = r.json().get("access_token")
        if not token:
            raise ValueError("Login failed: no access_token in response")
        self.session.headers["Authorization"] = f"Bearer {token}"

    def health(self) -> bool:
        try:
            r = self.session.get(f"{self.base_url}/health", timeout=5)
            return r.status_code == 200
        except requests.RequestException:
            return False

    def create_agent(self, name: str, template: str) -> dict[str, Any]:
        r = self.session.post(
            f"{self.base_url}/api/agents",
            json={"name": name, "template": template},
            timeout=60,
        )
        r.raise_for_status()
        return r.json()

    def get_agent(self, name: str) -> dict[str, Any] | None:
        r = self.session.get(f"{self.base_url}/api/agents/{name}", timeout=10)
        if r.status_code == 404:
            return None
        r.raise_for_status()
        return r.json()

    def inject_credentials(self, name: str, files: dict[str, str]) -> dict[str, Any]:
        r = self.session.post(
            f"{self.base_url}/api/agents/{name}/credentials/inject",
            json={"files": files},
            timeout=30,
        )
        r.raise_for_status()
        return r.json()

    def start_agent(self, name: str) -> dict[str, Any]:
        r = self.session.post(
            f"{self.base_url}/api/agents/{name}/start", timeout=60,
        )
        r.raise_for_status()
        return r.json()

    def list_agents(self) -> list[dict[str, Any]]:
        r = self.session.get(f"{self.base_url}/api/agents", timeout=10)
        r.raise_for_status()
        data = r.json()
        return data if isinstance(data, list) else data.get("agents", [])


# ---------------------------------------------------------------------------
# Registry
# ---------------------------------------------------------------------------

def fetch_registry(cfg: dict[str, Any]) -> dict[str, Any]:
    url = cfg.get("registry_url", DEFAULT_REGISTRY_URL)

    # Support local file path for development
    if url.startswith("/") or url.startswith("./"):
        path = Path(url)
        if not path.exists():
            print(f"{C.ERR}Registry file not found:{C.RESET} {url}")
            sys.exit(1)
        return yaml.safe_load(path.read_text())

    try:
        headers = {}
        gh_token = cfg.get("github_token")
        if gh_token:
            headers["Authorization"] = f"token {gh_token}"
        resp = requests.get(url, headers=headers, timeout=15)
        resp.raise_for_status()
        return yaml.safe_load(resp.text)
    except requests.RequestException as e:
        print(f"{C.ERR}Failed to fetch registry:{C.RESET} {e}")
        sys.exit(1)


# ---------------------------------------------------------------------------
# Infrastructure Setup (Local Database)
# ---------------------------------------------------------------------------

def find_trinity_dir() -> Path | None:
    """Find the Trinity project root by looking for docker-compose.yml."""
    # Check current directory and parents
    cwd = Path.cwd()
    for d in [cwd] + list(cwd.parents):
        if (d / "docker-compose.yml").exists() and (d / "config" / "agent-templates").exists():
            return d
        # Don't go too far up
        if d == d.parent:
            break
    return None


def setup_local_database(trinity_dir: Path | None) -> bool:
    """Set up local PostgreSQL + PostgREST for SMARTS inter-agent communication.

    Writes config files to ~/.trinity-market/smarts-db/ and runs docker compose.
    """
    db_dir = CONFIG_DIR / "smarts-db"
    db_dir.mkdir(parents=True, exist_ok=True)

    # Always write files (ensures config updates are applied)
    (db_dir / "docker-compose.yml").write_text(SMARTS_DOCKER_COMPOSE)
    (db_dir / "smarts-db-init.sql").write_text(SMARTS_INIT_SQL)
    (db_dir / "smarts-nginx.conf").write_text(SMARTS_NGINX_CONF)

    # Check if already running
    try:
        r = requests.get("http://localhost:3001/health", timeout=3)
        if r.status_code == 200:
            print(f"  {C.OK}Local database already running{C.RESET}")
            return True
    except requests.RequestException:
        pass

    # Check docker/docker compose available
    if not shutil.which("docker"):
        print(f"  {C.ERR}Docker not found. Install Docker to continue.{C.RESET}")
        return False

    print(f"  Writing database config to {db_dir}...")

    # Ensure the Docker network exists (Trinity creates it, but we need it)
    subprocess.run(
        ["docker", "network", "create", "trinity-agent-network"],
        capture_output=True,
    )

    # Start containers
    print(f"  Starting PostgreSQL + PostgREST...", end=" ", flush=True)
    result = subprocess.run(
        ["docker", "compose", "up", "-d"],
        cwd=str(db_dir),
        capture_output=True,
        text=True,
        timeout=120,
    )

    if result.returncode != 0:
        print(f"{C.ERR}failed{C.RESET}")
        print(f"  {result.stderr[:300]}")
        return False

    # Wait for PostgREST to be ready
    for i in range(30):
        try:
            r = requests.get("http://localhost:3001/health", timeout=2)
            if r.status_code == 200:
                print(f"{C.OK}ready{C.RESET}")

                # Verify database works
                r2 = requests.get(
                    "http://localhost:3001/rest/v1/integration_context?limit=0",
                    headers={
                        "apikey": LOCAL_DB_JWT,
                        "Authorization": f"Bearer {LOCAL_DB_JWT}",
                    },
                    timeout=5,
                )
                if r2.status_code == 200:
                    print(f"  {C.OK}Database verified (6 tables ready){C.RESET}")
                    return True
        except requests.RequestException:
            pass
        time.sleep(1)

    print(f"{C.WARN}timeout{C.RESET}")
    print(f"  Check logs: docker compose -f {db_dir}/docker-compose.yml logs")
    return False


# ---------------------------------------------------------------------------
# Credential Collection & Template Substitution
# ---------------------------------------------------------------------------

def collect_credentials(
    cred_defs: list[dict[str, Any]],
    env_file: str | None = None,
    set_values: list[str] | None = None,
) -> dict[str, str]:
    creds: dict[str, str] = {}

    if env_file:
        env_path = Path(env_file)
        if not env_path.exists():
            print(f"{C.ERR}Env file not found:{C.RESET} {env_file}")
            sys.exit(1)
        for line in env_path.read_text().splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            if "=" in line:
                key, _, value = line.partition("=")
                creds[key.strip()] = value.strip()

    if set_values:
        for item in set_values:
            if "=" not in item:
                print(f"{C.ERR}Invalid --set format:{C.RESET} {item}")
                sys.exit(1)
            key, _, value = item.partition("=")
            creds[key.strip()] = value.strip()

    for cred in cred_defs:
        name = cred["name"]
        if name in creds and creds[name]:
            continue
        required = cred.get("required", True)
        desc = cred.get("description", name)
        if required:
            prompt = f"  {C.BOLD}{name}{C.RESET} ({desc}): "
            is_secret = "secret" in name.lower() or "key" in name.lower()
            value = getpass.getpass(prompt) if is_secret else input(prompt)
            if not value:
                print(f"{C.ERR}Required credential '{name}' cannot be empty{C.RESET}")
                sys.exit(1)
            creds[name] = value
        else:
            prompt = f"  {C.DIM}{name}{C.RESET} ({desc}, optional - Enter to skip): "
            value = input(prompt)
            if value:
                creds[name] = value

    return creds


def build_env_content(creds: dict[str, str]) -> str:
    return "\n".join(f"{k}={v}" for k, v in creds.items()) + "\n"


def substitute_template(template: str, creds: dict[str, str]) -> str:
    def _replace(m: re.Match[str]) -> str:
        var_name = m.group(1)
        default = m.group(2)
        value = creds.get(var_name)
        if value is not None:
            return value
        if default is not None:
            return default
        return m.group(0)
    return PLACEHOLDER_RE.sub(_replace, template)


def fetch_mcp_template_from_dir(trinity_dir: Path, agent_template: str) -> str | None:
    """Fetch .mcp.json.template from Trinity's local agent-templates directory."""
    if not agent_template.startswith("local:"):
        return None
    template_name = agent_template[len("local:"):]
    template_path = trinity_dir / "config" / "agent-templates" / template_name / ".mcp.json.template"
    if template_path.exists():
        return template_path.read_text()
    return None


# ---------------------------------------------------------------------------
# Commands
# ---------------------------------------------------------------------------

def cmd_configure(args: argparse.Namespace) -> None:
    cfg = load_config()

    print(f"\n  {C.BOLD}Trinity Marketplace Configuration{C.RESET}\n")

    url = input(f"  Trinity URL [{cfg.get('trinity_url', 'http://localhost:8000')}]: ").strip()
    if not url:
        url = cfg.get("trinity_url", "http://localhost:8000")
    cfg["trinity_url"] = url

    print(f"\n  Authentication (choose one):")
    print(f"  1. Admin password (simplest - uses your Trinity admin login)")
    print(f"  2. MCP API key (from Trinity Settings > API Keys)")
    auth_choice = input(f"  Choice [1]: ").strip() or "1"

    if auth_choice == "2":
        key = getpass.getpass(f"  MCP API Key: ").strip()
        if key:
            cfg["api_key"] = key
            cfg.pop("admin_password", None)
        elif not cfg.get("api_key"):
            print(f"{C.ERR}API key is required{C.RESET}")
            return
    else:
        password = getpass.getpass(f"  Admin password: ").strip()
        if password:
            cfg["admin_password"] = password
            cfg.pop("api_key", None)
        elif not cfg.get("admin_password"):
            print(f"{C.ERR}Admin password is required{C.RESET}")
            return

    registry = input(
        f"  Registry URL [{cfg.get('registry_url', DEFAULT_REGISTRY_URL)}]: "
    ).strip()
    if registry:
        cfg["registry_url"] = registry

    save_config(cfg)

    # Test connection
    try:
        api = _make_api(cfg)
        if api.health():
            print(f"\n  {C.OK}Connected to Trinity at {cfg['trinity_url']}{C.RESET}")
        else:
            print(f"\n  {C.WARN}Warning: Could not reach Trinity at {cfg['trinity_url']}{C.RESET}")
    except Exception as e:
        print(f"\n  {C.ERR}Auth failed: {e}{C.RESET}")
        print(f"  Check your credentials and try again.")
        return

    print(f"  Config saved to {CONFIG_FILE}\n")


def _make_api(cfg: dict[str, Any]) -> TrinityAPI:
    """Create TrinityAPI from config, supporting both auth methods."""
    return TrinityAPI(
        cfg["trinity_url"],
        api_key=cfg.get("api_key"),
        admin_password=cfg.get("admin_password"),
    )


def cmd_list(args: argparse.Namespace) -> None:
    cfg = get_config_or_exit()
    registry = fetch_registry(cfg)
    agents = registry.get("agents", {})

    if not agents:
        print("No agents found in registry.")
        return

    category_filter = getattr(args, "category", None)

    print(f"\n  {'NAME':<22} {'TYPE':<8} {'VERSION':<9} DESCRIPTION")
    print(f"  {'─' * 22} {'─' * 8} {'─' * 9} {'─' * 40}")

    for name, info in sorted(agents.items()):
        if category_filter:
            cats = info.get("categories", [])
            if category_filter.lower() not in [c.lower() for c in cats]:
                continue
        agent_type = info.get("type", "single")
        version = info.get("version", "?")
        desc = info.get("display_name", name)
        count = ""
        if agent_type == "system":
            count = f" ({info.get('agent_count', '?')} agents)"
        print(f"  {name:<22} {agent_type:<8} {version:<9} {desc}{count}")

    print()


def cmd_search(args: argparse.Namespace) -> None:
    cfg = get_config_or_exit()
    registry = fetch_registry(cfg)
    agents = registry.get("agents", {})
    query = args.query.lower()

    matches = {}
    for name, info in agents.items():
        searchable = " ".join([
            name, info.get("display_name", ""),
            info.get("description", ""),
            " ".join(info.get("categories", [])),
        ]).lower()
        if query in searchable:
            matches[name] = info

    if not matches:
        print(f"No agents matching '{args.query}'")
        return

    print(f"\n  Found {len(matches)} result(s) for '{args.query}':\n")
    for name, info in matches.items():
        print(f"  {C.BOLD}{name}{C.RESET} v{info.get('version', '?')} — {info.get('display_name', name)}")
        print(f"    {info.get('description', '')[:80]}")
        print()


def cmd_info(args: argparse.Namespace) -> None:
    cfg = get_config_or_exit()
    registry = fetch_registry(cfg)
    entry = registry.get("agents", {}).get(args.name)

    if not entry:
        print(f"{C.ERR}Agent '{args.name}' not found in registry{C.RESET}")
        sys.exit(1)

    print(f"\n  {C.BOLD}{entry.get('display_name', args.name)}{C.RESET} v{entry.get('version', '?')}")
    print(f"  Author: {entry.get('author', 'Unknown')}")
    print(f"  Type: {entry.get('type', 'single')}", end="")
    if entry.get("agent_count"):
        print(f" ({entry['agent_count']} agents)")
    else:
        print()

    desc = entry.get("description", "")
    if desc:
        print(f"\n  {desc}\n")

    creds = entry.get("credentials", [])
    if creds:
        required = [c for c in creds if c.get("required", True)]
        optional = [c for c in creds if not c.get("required", True)]
        if required:
            print(f"  {C.BOLD}Required credentials:{C.RESET}")
            for c in required:
                print(f"    {c['name']:<25} {c.get('description', '')}")
        if optional:
            print(f"\n  {C.DIM}Optional credentials:{C.RESET}")
            for c in optional:
                print(f"    {c['name']:<25} {c.get('description', '')}")
        print()

    infra = entry.get("infrastructure", {})
    if infra.get("local_database", {}).get("enabled"):
        print(f"  {C.BOLD}Infrastructure (auto-provisioned):{C.RESET}")
        print(f"    Local PostgreSQL + PostgREST (no external database needed)")
        print()


def cmd_install(args: argparse.Namespace) -> None:
    cfg = get_config_or_exit()
    registry = fetch_registry(cfg)
    entry = registry.get("agents", {}).get(args.name)

    if not entry:
        print(f"{C.ERR}Agent '{args.name}' not found in registry{C.RESET}")
        sys.exit(1)

    try:
        api = _make_api(cfg)
    except Exception as e:
        print(f"{C.ERR}Authentication failed:{C.RESET} {e}")
        sys.exit(1)

    if not api.health():
        print(f"{C.ERR}Cannot reach Trinity at {cfg['trinity_url']}{C.RESET}")
        print(f"Start Trinity first: ./scripts/deploy/start.sh")
        sys.exit(1)

    agent_type = entry.get("type", "single")
    display = entry.get("display_name", args.name)
    version = entry.get("version", "?")

    if agent_type == "system":
        _install_system(args, cfg, entry, api, display, version)
    else:
        _install_single(args, cfg, entry, api, display, version)


def _install_single(
    args: argparse.Namespace, cfg: dict[str, Any], entry: dict[str, Any],
    api: TrinityAPI, display: str, version: str,
) -> None:
    print(f"\n  Installing {C.BOLD}{display}{C.RESET} v{version}...\n")

    # Collect credentials
    cred_defs = entry.get("credentials", [])
    print(f"  {C.BOLD}Credentials:{C.RESET}")
    creds = collect_credentials(cred_defs, env_file=args.env_file, set_values=args.set)

    default_name = args.agent_name or args.name
    if not args.agent_name and sys.stdin.isatty():
        name_input = input(f"\n  Agent name [{default_name}]: ").strip()
        agent_name = name_input or default_name
    else:
        agent_name = default_name

    template = entry.get("template", "")

    # Create agent
    print(f"\n  Creating agent '{agent_name}'...", end=" ", flush=True)
    try:
        api.create_agent(agent_name, template)
        print(f"{C.OK}done{C.RESET}")
    except requests.HTTPError as e:
        if e.response is not None and "already exists" in e.response.text.lower():
            print(f"{C.WARN}already exists{C.RESET}")
        else:
            print(f"{C.ERR}failed: {e}{C.RESET}")
            sys.exit(1)

    _wait_for_agent(api, agent_name)

    # Build credential files
    env_content = build_env_content(creds)
    files: dict[str, str] = {".env": env_content}

    # Try to get .mcp.json.template from local Trinity directory
    trinity_dir = find_trinity_dir()
    if trinity_dir:
        mcp_template = fetch_mcp_template_from_dir(trinity_dir, template)
        if mcp_template:
            files[".mcp.json"] = substitute_template(mcp_template, creds)

    # Inject & start
    print(f"  Injecting credentials...", end=" ", flush=True)
    try:
        api.inject_credentials(agent_name, files)
        print(f"{C.OK}done{C.RESET}")
    except requests.HTTPError as e:
        print(f"{C.ERR}failed: {e}{C.RESET}")

    print(f"  Starting agent...", end=" ", flush=True)
    try:
        api.start_agent(agent_name)
        print(f"{C.OK}done{C.RESET}")
    except requests.HTTPError:
        print(f"{C.WARN}already running{C.RESET}")

    print(f"\n  {C.OK}Agent '{agent_name}' is running!{C.RESET}\n")


def _install_system(
    args: argparse.Namespace, cfg: dict[str, Any], entry: dict[str, Any],
    api: TrinityAPI, display: str, version: str,
) -> None:
    agent_count = entry.get("agent_count", "?")
    print(f"\n  Installing {C.BOLD}{display}{C.RESET} v{version} ({agent_count} agents)...\n")

    # Step 1: Infrastructure
    infra = entry.get("infrastructure", {})
    db_creds: dict[str, str] = {}

    if infra.get("local_database", {}).get("enabled"):
        print(f"  {C.BOLD}[1/4] Setting up local database{C.RESET}")
        trinity_dir = find_trinity_dir()
        if setup_local_database(trinity_dir):
            db_creds["SUPABASE_URL"] = LOCAL_DB_URL
            db_creds["SUPABASE_SERVICE_KEY"] = LOCAL_DB_JWT
            db_creds["MASSIVE_FOLDER"] = "/shared"
        else:
            print(f"  {C.ERR}Database setup failed. Cannot continue.{C.RESET}")
            sys.exit(1)
    else:
        print(f"  {C.BOLD}[1/4] No infrastructure needed{C.RESET}")

    # Step 2: Collect credentials (only user-provided ones — DB creds are auto-set)
    print(f"\n  {C.BOLD}[2/4] Collecting credentials{C.RESET}")
    cred_defs = entry.get("credentials", [])
    creds = collect_credentials(cred_defs, env_file=args.env_file, set_values=args.set)

    # Merge auto-provisioned credentials
    creds.update(db_creds)

    # Step 3: Create all agents (containers start building in parallel)
    print(f"\n  {C.BOLD}[3/4] Creating agents{C.RESET}")

    agent_defs = entry.get("agents", [])
    if not agent_defs:
        print(f"  {C.ERR}No agents defined in registry entry{C.RESET}")
        sys.exit(1)

    trinity_dir = find_trinity_dir()
    agents_to_configure: list[tuple[str, str]] = []  # (agent_name, template)

    for i, agent_def in enumerate(agent_defs):
        agent_template_name = agent_def["name"]
        agent_name = f"smarts-{agent_template_name}"
        template = agent_def.get("template", f"local:{agent_template_name}")

        print(f"  {agent_name}...", end=" ", flush=True)

        try:
            api.create_agent(agent_name, template)
            print(f"{C.OK}created{C.RESET}")
            agents_to_configure.append((agent_name, template))
        except requests.HTTPError as e:
            if e.response is not None and "already exists" in e.response.text.lower():
                print(f"{C.WARN}already exists{C.RESET}")
                agents_to_configure.append((agent_name, template))
            else:
                print(f"{C.ERR}failed{C.RESET}")
        except requests.ConnectionError:
            # Backend may be under load from building containers — wait and retry once
            print("waiting...", end=" ", flush=True)
            time.sleep(10)
            try:
                api.create_agent(agent_name, template)
                print(f"{C.OK}created{C.RESET}")
                agents_to_configure.append((agent_name, template))
            except requests.HTTPError as e:
                if e.response is not None and "already exists" in e.response.text.lower():
                    print(f"{C.WARN}already exists{C.RESET}")
                    agents_to_configure.append((agent_name, template))
                else:
                    print(f"{C.ERR}failed{C.RESET}")
            except requests.RequestException:
                print(f"{C.ERR}failed (connection error){C.RESET}")

        # Pace creation to avoid overwhelming the backend
        if i < len(agent_defs) - 1:
            time.sleep(3)

    if not agents_to_configure:
        print(f"  {C.ERR}No agents created successfully{C.RESET}")
        sys.exit(1)

    # Step 4: Wait for all containers to start, then inject credentials
    print(f"\n  {C.BOLD}[4/4] Configuring agents{C.RESET}")
    print(f"  Waiting for containers to be ready...", flush=True)
    time.sleep(10)  # Give all containers time to start SSH servers

    env_content = build_env_content(creds)
    configured = 0
    failed = 0

    for agent_name, template in agents_to_configure:
        print(f"  {agent_name}...", end=" ", flush=True)

        # Build credential files
        files: dict[str, str] = {".env": env_content}
        if trinity_dir:
            mcp_template = fetch_mcp_template_from_dir(trinity_dir, template)
            if mcp_template:
                files[".mcp.json"] = substitute_template(mcp_template, creds)

        # Retry injection with backoff (agent SSH server may need time to start)
        injected = False
        for attempt in range(15):
            try:
                # Ensure agent is started
                agent_info = api.get_agent(agent_name)
                if agent_info and agent_info.get("status") not in ("running", "ready"):
                    try:
                        api.start_agent(agent_name)
                    except requests.HTTPError:
                        pass

                api.inject_credentials(agent_name, files)
                injected = True
                break
            except (requests.HTTPError, requests.ConnectionError):
                if attempt < 14:
                    time.sleep(5)
                    print(".", end="", flush=True)

        if injected:
            print(f" {C.OK}configured{C.RESET}")
            configured += 1
        else:
            print(f" {C.ERR}failed (agent not ready after 75s){C.RESET}")
            failed += 1

    # Summary
    print(f"\n  Configured: {configured} | Failed: {failed}")
    if failed == 0:
        print(f"\n  {C.OK}SMARTS Trading Pipeline deployed!{C.RESET}")
    else:
        print(f"\n  {C.WARN}Partially deployed ({failed} agent(s) failed).{C.RESET}")
        print(f"  Retry with: trinity-market install smarts-pipeline")
    print(f"\n  Next steps:")
    print(f"    1. Open http://localhost in your browser")
    print(f"    2. Login as admin")
    print(f"    3. Navigate to any smarts-* agent")
    print(f"    4. Try: 'What is the current market regime?'")
    print()


def _wait_for_agent(api: TrinityAPI, name: str, timeout: int = 30, quiet: bool = False) -> None:
    start = time.time()
    while time.time() - start < timeout:
        agent = api.get_agent(name)
        if agent and agent.get("status") in ("running", "ready", "idle"):
            return
        time.sleep(2)
    if not quiet:
        print(f"{C.WARN}(timeout){C.RESET}")


def cmd_status(args: argparse.Namespace) -> None:
    cfg = get_config_or_exit()
    try:
        api = _make_api(cfg)
    except Exception as e:
        print(f"{C.ERR}Auth failed: {e}{C.RESET}")
        sys.exit(1)

    if not api.health():
        print(f"{C.ERR}Cannot reach Trinity at {cfg['trinity_url']}{C.RESET}")
        sys.exit(1)

    agents = api.list_agents()
    if not agents:
        print("\n  No agents installed.")
        return

    print(f"\n  {'NAME':<25} {'STATUS':<12} {'TYPE':<15}")
    print(f"  {'─' * 25} {'─' * 12} {'─' * 15}")

    for agent in agents:
        name = agent.get("name", "?")
        status = agent.get("status", "unknown")
        agent_type = agent.get("type", agent.get("agent_type", ""))

        if status in ("running", "ready"):
            status_str = f"{C.OK}{status}{C.RESET}"
        elif status in ("stopped", "exited"):
            status_str = f"{C.DIM}{status}{C.RESET}"
        elif status in ("error", "failed"):
            status_str = f"{C.ERR}{status}{C.RESET}"
        else:
            status_str = status

        print(f"  {name:<25} {status_str:<22} {agent_type}")
    print()


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main() -> None:
    parser = argparse.ArgumentParser(
        prog="trinity-market",
        description="Trinity Agent Marketplace CLI",
    )
    parser.add_argument("--version", action="version", version=f"trinity-market {VERSION}")
    sub = parser.add_subparsers(dest="command")

    sub.add_parser("configure", help="Configure Trinity connection")

    p_list = sub.add_parser("list", help="List available agents")
    p_list.add_argument("--category", help="Filter by category")

    p_search = sub.add_parser("search", help="Search agents")
    p_search.add_argument("query", help="Search keyword")

    p_info = sub.add_parser("info", help="Show agent details")
    p_info.add_argument("name", help="Agent name from registry")

    p_install = sub.add_parser("install", help="Install an agent or system")
    p_install.add_argument("name", help="Agent name from registry")
    p_install.add_argument("--agent-name", help="Custom name for the installed agent")
    p_install.add_argument("--env-file", help="Path to .env file with credentials")
    p_install.add_argument("--set", action="append", help="Set credential: KEY=VALUE")

    sub.add_parser("status", help="Show installed agents")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(0)

    commands = {
        "configure": cmd_configure,
        "list": cmd_list,
        "search": cmd_search,
        "info": cmd_info,
        "install": cmd_install,
        "status": cmd_status,
    }

    commands[args.command](args)


if __name__ == "__main__":
    main()
